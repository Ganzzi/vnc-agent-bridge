# WebSocket VNC Support with URL Templates - v0.3.0 Integration Plan

**Document Date:** October 27, 2025 (Generic WebSocket Approach)
**Version:** v0.3.0 - Separate from v0.2.0
**Status:** Planning & Architecture  
**Type:** Independent version roadmap

## Executive Summary

This document outlines **generic WebSocket support for VNC-over-WebSocket servers** with flexible URL templates. Users provide URL templates with `${}` placeholders for their specific VNC server. This enables support for:
- Proxmox VNC WebSocket (one example)
- Custom WebSocket VNC servers (any implementation)
- Any VNC server using WebSocket transport

The library is server-agnostic and flexible, supporting any WebSocket VNC configuration.

## Current Architecture vs. Requirements

### Current State
- **Transport:** Direct TCP socket to VNC server (port 5900)
- **Protocol:** RFB 3.8 binary protocol over raw TCP
- **Connection Model:** `VNCConnection` class handles all TCP communication

### New Requirements (v0.3.0)
- **Transport:** WebSocket over TLS (wss://)
- **URL Templates:** Flexible patterns with `${host}`, `${port}`, `${ticket}` placeholders
- **Server-Agnostic:** Works with any WebSocket VNC implementation
- **Protocol:** RFB 3.8 binary protocol wrapped in WebSocket frames

## Architecture Design

### 1. Connection Strategy Pattern

Create an abstract base class to support multiple connection types:

```python
from abc import ABC, abstractmethod

class VNCConnectionBase(ABC):
    """Abstract base class for VNC connection strategies."""
    
    @abstractmethod
    def connect(self) -> None:
        """Establish connection to VNC server."""
        pass
    
    @abstractmethod
    def disconnect(self) -> None:
        """Close connection."""
        pass
    
    @abstractmethod
    def send_pointer_event(self, x: int, y: int, button_mask: int) -> None:
        """Send mouse pointer event."""
        pass
    
    @abstractmethod
    def send_key_event(self, keycode: int, pressed: bool) -> None:
        """Send keyboard event."""
        pass
    
    @property
    @abstractmethod
    def is_connected(self) -> bool:
        """Check connection status."""
        pass
```

### 2. Implementation Classes

#### A. TCPVNCConnection (refactored from VNCConnection)
- Inherits from `VNCConnectionBase`
- Implements standard TCP socket connection
- Maintains RFB 3.8 protocol handling
- **Backward Compatibility:** Can be aliased as `VNCConnection` for existing code

#### B. WebSocketVNCConnection (new)
- Inherits from `VNCConnectionBase`
- Implements WebSocket connection (wss://)
- Handles TLS/SSL verification
- Wraps RFB protocol messages in WebSocket frames
- Server-agnostic (works with any WebSocket VNC server)
- Users provide URL template and parameters

### 3. Design Principle: URL Templates (Server-Agnostic) ⭐

**CRITICAL:** The library does NOT hardcode server-specific logic.

**Responsibility Split:**
```
USER RESPONSIBILITY:
1. Define URL template for their WebSocket VNC server
2. Provide connection parameters (host, port, ticket, etc.)
3. Pass to library

LIBRARY RESPONSIBILITY:
1. Substitute `${}` placeholders in URL template
2. Create WebSocket connection to resulting URL
3. Handle RFB protocol
4. Manage connection lifecycle
```

**Why This Approach?**
- ✅ Server-agnostic (works with Proxmox, custom servers, etc.)
- ✅ Flexible (users define their own URL patterns)
- ✅ Simple (string substitution, no magic)
- ✅ Powerful (supports any WebSocket VNC configuration)
- ✅ Better Security (credentials stay in user code)

### 4. URL Template Pattern

Users provide templates and parameters:
```
Template: "wss://${host}:${port}/api/vnc?ticket=${ticket}"
Host: "proxmox.example.com"
Port: 6900
Ticket: "PVE:node:xxxxx"

Result: "wss://proxmox.example.com:6900/api/vnc?ticket=PVE:node:xxxxx"
```

### 5. Convenience Helper Functions

Simple parameter wrappers (NOT server-specific):

```python
def create_websocket_vnc(
    url_template: str,
    host: str,
    port: int,
    ticket: str,
    password: Optional[str] = None,
    verify_ssl: bool = True,
) -> VNCAgentBridge:
    """Create VNCAgentBridge with WebSocket connection.
    
    Args:
        url_template: URL with ${host}, ${port}, ${ticket}, ${password}
        host: Connection host
        port: Connection port
        ticket: Auth ticket/token
        password: Optional auth password
        verify_ssl: Verify SSL certificate
    
    Returns:
        Connected VNCAgentBridge instance
    """
    ws_conn = WebSocketVNCConnection(
        url_template=url_template,
        host=host,
        port=port,
        ticket=ticket,
        password=password,
        verify_ssl=verify_ssl,
    )
    bridge = VNCAgentBridge(connection=ws_conn)
    bridge.connect()
    return bridge
```

**This is NOT server-specific** - it's a generic helper for any WebSocket VNC server.

## Implementation Phases

### Phase 1: Connection Strategy Implementation (4-5 hours)
**Objective:** Create WebSocket support with URL template pattern

**Files to Create/Modify:**
- `vnc_agent_bridge/core/base_connection.py` - Abstract base
- `vnc_agent_bridge/core/connection_tcp.py` - TCP implementation
- `vnc_agent_bridge/core/connection_websocket.py` - WebSocket with templates
- `vnc_agent_bridge/core/bridge.py` - Updated to accept VNCConnectionBase

**Key Tasks:**
1. Create `VNCConnectionBase` abstract class
2. Refactor `VNCConnection` → `TCPVNCConnection`
3. Create `WebSocketVNCConnection` with URL template support
   - Accept `url_template` parameter
   - Implement `${host}`, `${port}`, `${ticket}`, `${password}` substitution
4. Update VNCAgentBridge to accept custom connections
5. Add comprehensive type hints
6. Create unit tests (mock WebSocket)

**Dependencies to Add:**
- `websocket-client` (optional)

### Phase 2: Convenience Helpers & Documentation (2-3 hours)
**Objective:** Helper functions and usage documentation

**Files to Create:**
- Documentation on URL template patterns
- Examples for multiple WebSocket VNC servers
- `create_websocket_vnc()` helper function

**Key Tasks:**
1. Create `create_websocket_vnc()` helper
2. Document URL template format
3. Provide example with Proxmox (and other WebSocket VNC servers)
4. Document parameter substitution
5. Unit tests for helpers

### Phase 3: Testing & Quality (1-2 hours)
**Objective:** Comprehensive testing and documentation

**Files to Create/Update:**
- Comprehensive test suite
- API documentation
- Multiple usage examples
- Security best practices
- README updates

**Key Tasks:**
1. Unit tests for WebSocket connection
2. Tests for URL template substitution
3. Tests for various URL patterns
4. Integration tests
5. Type checking (mypy --strict)
6. Code formatting (black)
7. Linting (flake8)

## Dependencies Analysis

### Current
- **Core:** None (stdlib only)
- **Development:** pytest, mypy, flake8, black

### New (Optional)
- **websocket-client** (for WebSocket support)
  - Import: `try: import websocket except ImportError: ...`
  - Graceful fallback: Raise helpful error if not installed
  - Size: ~50KB

- **requests** (alternative for HTTP, or use urllib)
  - Only needed if using `requests` instead of stdlib `urllib`
  - Recommendation: Use `urllib` from stdlib for zero new deps

### Decision: Minimize New Dependencies
- **WebSocket:** `websocket-client` is small and focused
- **HTTP:** Use `urllib` from Python stdlib
- Both marked as optional in `pyproject.toml`
- Errors guide users to install them if needed

## Design Decisions

### Decision 1: Base Class Pattern vs. Composition
**Options:**
- A) Abstract base class (inheritance)
- B) Protocol class (typing.Protocol)
- C) Composition (wrap connection)

**Decision:** Abstract base class
**Rationale:**
- Clear interface contract
- Easy to enforce with mypy
- Standard OOP pattern
- Allows isinstance() checks
- Type safe at runtime

### Decision 2: VNCConnection Naming
**Options:**
- A) Rename to TCPVNCConnection everywhere (breaking)
- B) Keep VNCConnection as alias (backward compatible)
- C) Create factory function

**Decision:** Keep `VNCConnection` as alias
**Rationale:**
- Full backward compatibility
- Existing code works without changes
- New code can use explicit `TCPVNCConnection`
- Clear intent: "old code uses VNCConnection, new uses TCP/WebSocket"

### Decision 3: Proxmox Helper as Separate Module
**Options:**
- A) Add to existing connection.py
- B) Separate module vnc_agent_bridge/proxmox/
- C) Factory method in main module

**Decision:** Separate module `vnc_agent_bridge/proxmox/`
**Rationale:**
- Proxmox-specific functionality isolated
- Optional feature (users don't need if using standard VNC)
- Cleaner imports: `from vnc_agent_bridge.proxmox import ProxmoxVNCBridge`
- Easy to document separately

### Decision 4: Certificate Validation
**Options:**
- A) Always verify (secure by default)
- B) Always skip (simpler, less secure)
- C) Configurable with secure default

**Decision:** Configurable, verify by default
**Rationale:**
- Secure by default (best practice)
- Allow `verify_ssl=False` for development
- Document security implications
- Users explicitly opt into insecure mode

## API Changes Summary

### New Public APIs

```python
# Base connection class (new)
from vnc_agent_bridge.core import VNCConnectionBase

# WebSocket connection (new, with URL template support)
from vnc_agent_bridge.core import WebSocketVNCConnection

# Optional convenience helper (new)
from vnc_agent_bridge.core import create_websocket_vnc

# Backward compatible (unchanged)
from vnc_agent_bridge import VNCConnection  # Still works (alias for TCP)
from vnc_agent_bridge.core import VNCConnection  # Still works (alias)
from vnc_agent_bridge.core import TCPVNCConnection  # New explicit name
```

### WebSocketVNCConnection Constructor

```python
ws_conn = WebSocketVNCConnection(
    url_template: str,           # e.g., "wss://${host}:${port}/vnc?ticket=${ticket}"
    host: str,                   # Connection host
    port: int,                   # Connection port
    ticket: str,                 # Auth ticket/token
    password: Optional[str] = None,  # Optional auth password
    verify_ssl: bool = True,     # Verify SSL certificate
    timeout: float = 10.0,       # Connection timeout
)
```

**URL Template Placeholders:**
- `${host}` - Connection host
- `${port}` - Connection port
- `${ticket}` - Auth ticket/token
- `${password}` - Auth password (if applicable)

**Example:**
```python
# Proxmox
template = "wss://${host}:${port}/api2/json/nodes/pve/qemu/100/vncwebsocket?vncticket=${ticket}"

# Custom server
template = "wss://${host}/vnc/websocket?token=${ticket}"

# Static host
template = "wss://vnc.example.com:6900/connect?ticket=${ticket}"
```


## Testing Strategy

### Unit Tests (Mock-Based)
- Mock WebSocket connections
- Mock Proxmox API responses
- Test RFB message handling
- Test error scenarios
- Test TLS parameter handling

### Integration Tests
- Test complete workflows
- Test error recovery
- Test connection lifecycle
- Test backward compatibility

### Coverage Goals
- Connection layer: 85%+
- Proxmox helper: 90%+
- Bridge: 85%+
- Overall: Maintain 85%+ (or higher)

## Backward Compatibility

### Guarantee
✅ 100% backward compatible with v0.2.0

### Why
1. `VNCConnection` remains importable (alias)
2. Existing APIs unchanged
3. New features are opt-in
4. Default behavior identical

### Verification
- All v0.2.0 tests pass without modification
- VNCAgentBridge works identically
- Controllers work identically
- Only new code uses WebSocket/Proxmox

## Documentation Plan

### New Guides
1. `docs/guides/proxmox_integration.md` (1000+ lines)
   - Architecture overview
   - Setup instructions
   - API integration examples
   - Error handling guide

2. `docs/api/proxmox.md` (600+ lines)
   - ProxmoxVNCBridge API
   - ProxmoxVNCHelper API
   - WebSocketVNCConnection API
   - Examples

### Updated Documentation
- README.md: Add Proxmox section
- CHANGELOG.md: v0.3.0 release notes
- examples/proxmox_vnc.py: Working example

### Example Scripts
- `examples/proxmox_basic.py` - Simple connection
- `examples/proxmox_advanced.py` - Advanced patterns
- `examples/proxmox_error_handling.py` - Error scenarios

## Risk Analysis

### Technical Risks
1. **WebSocket Protocol Edge Cases**
   - Mitigation: Use battle-tested `websocket-client` library
   - Testing: Comprehensive mock tests

2. **Proxmox API Variations**
   - Mitigation: Document API version assumptions
   - Testing: Mock various response formats

3. **TLS Certificate Issues**
   - Mitigation: Configurable verification
   - Testing: Test with mock certs

### Dependency Risks
1. **websocket-client version compatibility**
   - Mitigation: Use version range, semantic versioning
   - Testing: Test with multiple versions

2. **Breaking changes in dependencies**
   - Mitigation: Pin versions in requirements
   - Testing: Update lock file

### Adoption Risks
1. **User confusion with dual connections**
   - Mitigation: Clear documentation
   - Testing: Example scripts for common patterns

2. **Performance regression**
   - Mitigation: WebSocket overhead ~5-10% acceptable
   - Testing: Benchmark tests

## Success Criteria

### Completion Checklist
- ✅ Connection strategy pattern implemented
- ✅ TCPVNCConnection created (refactored from VNCConnection)
- ✅ WebSocketVNCConnection working
- ✅ ProxmoxVNCHelper completed
- ✅ ProxmoxVNCBridge convenience class done
- ✅ All new code with 100% type hints
- ✅ 85%+ test coverage (new code)
- ✅ 100% mypy strict compliance
- ✅ 0 flake8 errors
- ✅ 100% black compliant
- ✅ Comprehensive documentation
- ✅ Working examples
- ✅ All v0.2.0 tests still pass
- ✅ Backward compatibility verified

## Future Enhancements

1. **Async Support**
   - `AsyncWebSocketVNCConnection`
   - `AsyncProxmoxVNCBridge`

2. **Connection Pooling**
   - Multiple VM connections
   - Connection caching

3. **Advanced Features**
   - Proxmox 8.0+ features
   - Node failover
   - Cluster support

4. **Performance**
   - WebSocket compression
   - Frame batching
   - Bandwidth optimization

## Conclusion

This integration maintains the VNC Agent Bridge's focus on simplicity and reliability while adding enterprise-grade Proxmox support. The connection strategy pattern enables future extensibility (SPICE, RDP, etc.) while preserving full backward compatibility.

The phased approach allows for iterative development with clear checkpoints, comprehensive testing at each phase, and rapid feedback incorporation.
