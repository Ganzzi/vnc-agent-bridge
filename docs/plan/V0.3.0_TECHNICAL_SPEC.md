# WebSocket VNC Technical Specification - v0.3.0

**Document Date:** October 27, 2025  
**Version:** v0.3.0
**Status:** Technical Design Phase  
**Scope:** Generic WebSocket VNC connection support

⭐ **CRITICAL DESIGN PRINCIPLE**

This document describes the **generic WebSocket connection mechanism**. The VNC Agent Bridge library does NOT call server-specific APIs. Users must handle their VNC server's authentication/setup themselves (Proxmox API, custom cloud service, config file, etc.).

**What the library does:** Creates WebSocket connections using provided parameters (host, port, ticket/token, certificate).  
**What users do:** Get those parameters from their VNC server provider.

## 1. WebSocket Connection Implementation

### 1.1 WebSocket Protocol Details

```python
# Connection: wss://${host}:${port}/path/to/vnc/websocket
# Protocol: WebSocket with TLS
# Frame Type: Binary/Text frames containing RFB messages
# Authentication: User-specific (query params, headers, etc.)
```

### 1.2 RFB Message Encoding in WebSocket

RFB messages are sent/received through WebSocket frames:

```
Client → Server:
1. Connect to WebSocket (wss://)
2. Send RFB handshake messages through WebSocket
3. Send RFB events (pointer, key) through WebSocket

Server → Client:
1. Send RFB protocol messages through WebSocket
2. Data encoding handled by WebSocket layer
```

### 1.3 Authentication Flow (USER RESPONSIBILITY - SERVER-SPECIFIC)

**Step 1: User gets connection parameters from their VNC server**
```
Examples:
- Proxmox: Call POST /api2/json/nodes/{node}/qemu/{vmid}/vncproxy
- Custom: Load from config file / environment variables
- Cloud: Call proprietary API endpoint
- Other: Whatever your server requires
```

**Step 2: User receives connection info**
```json
Example from Proxmox:
{
  "host": "proxmox.example.com",
  "port": 6900,
  "ticket": "PVE:node:xxxxxxx",
  "cert": "-----BEGIN CERTIFICATE-----\n...",
  "url_template": "wss://${host}:${port}/api2/json/nodes/pve/qemu/100/vncwebsocket?vncticket=${ticket}"
}

Example from custom server:
{
  "host": "vnc.example.com",
  "port": 8080,
  "ticket": "token_xxxxx",
  "url_template": "wss://${host}:${port}/vnc/websocket?token=${ticket}"
}
```

**Step 3: User passes parameters to library**
```python
# User's code - handles their specific VNC server
connection_params = {...}  # Got from their VNC server

# Library's code - only creates WebSocket connection
ws_conn = WebSocketVNCConnection(
    url_template=connection_params['url_template'],
    host=connection_params['host'],
    port=connection_params['port'],
    ticket=connection_params['ticket'],
    certificate=connection_params.get('cert'),
    verify_ssl=True,
)
```

**Step 4: Library connects to WebSocket**
```
1. Substitutes ${host}, ${port}, ${ticket} in url_template
2. Result: actual WebSocket URL
3. Connects to wss://...
```

**Step 5: Library performs RFB handshake** (standard RFB 3.8 protocol)

### Key Point: NO API CALLS IN LIBRARY ⭐
- User: Calls Proxmox API, gets ticket/port/cert
- Library: Creates WebSocket connection using those parameters
- User: Never shares credentials with library

### 1.4 Implementation Example

```python
import websocket
import ssl
from typing import Optional

class WebSocketVNCConnection(VNCConnectionBase):
    """VNC connection via WebSocket (for Proxmox)."""
    
    def __init__(
        self,
        host: str,
        port: int,
        ticket: str,
        cert_path: Optional[str] = None,
        verify_ssl: bool = True,
        timeout: float = 10.0,
    ) -> None:
        self.host = host
        self.port = port
        self.ticket = ticket
        self.cert_path = cert_path
        self.verify_ssl = verify_ssl
        self.timeout = timeout
        
        self._ws: Optional[websocket.WebSocket] = None
        self._connected = False
    
    def connect(self) -> None:
        """Connect to VNC server via WebSocket."""
        try:
            # Build WebSocket URL
            ws_url = f"wss://{self.host}:{self.port}/vncwebsocket"
            ws_url += f"?vncticket={self.ticket}"
            
            # Create SSL context
            ssl_context = ssl.create_default_context()
            if not self.verify_ssl:
                ssl_context.check_hostname = False
                ssl_context.verify_mode = ssl.CERT_NONE
            elif self.cert_path:
                ssl_context.load_verify_locations(self.cert_path)
            
            # Connect
            self._ws = websocket.create_connection(
                ws_url,
                sslopt={"context": ssl_context},
                timeout=self.timeout,
            )
            
            # RFB handshake
            self._perform_handshake()
            
            self._connected = True
        except Exception as e:
            raise VNCConnectionError(f"WebSocket connection failed: {e}")
    
    def disconnect(self) -> None:
        """Close WebSocket connection."""
        if self._ws:
            try:
                self._ws.close()
            except Exception:
                pass
        self._ws = None
        self._connected = False
    
    def send_pointer_event(self, x: int, y: int, button_mask: int) -> None:
        """Send pointer event through WebSocket."""
        self._validate_connection()
        data = struct.pack("!BBHH", self.POINTER_EVENT, button_mask, x, y)
        self._send_raw(data)
    
    def send_key_event(self, keycode: int, pressed: bool) -> None:
        """Send key event through WebSocket."""
        self._validate_connection()
        down_flag = 1 if pressed else 0
        data = struct.pack("!BBHI", self.KEY_EVENT, down_flag, 0, keycode)
        self._send_raw(data)
    
    @property
    def is_connected(self) -> bool:
        """Check if connected."""
        return self._connected and self._ws is not None
    
    def _send_raw(self, data: bytes) -> None:
        """Send raw bytes through WebSocket."""
        if not self._ws:
            raise VNCConnectionError("No WebSocket available")
        try:
            self._ws.send_binary(data)
        except Exception as e:
            self._cleanup()
            raise VNCConnectionError(f"Failed to send: {e}")
    
    def _recv_exact(self, count: int) -> bytes:
        """Receive exactly count bytes."""
        if not self._ws:
            raise VNCConnectionError("No WebSocket available")
        try:
            data = b""
            while len(data) < count:
                chunk = self._ws.recv_frame()
                if not chunk.data:
                    raise VNCConnectionError("Connection closed")
                data += chunk.data
                if len(data) >= count:
                    break
            return data[:count]
        except Exception as e:
            self._cleanup()
            raise VNCConnectionError(f"Failed to receive: {e}")
    
    def _cleanup(self) -> None:
        """Clean up resources."""
        if self._ws:
            try:
                self._ws.close()
            except Exception:
                pass
        self._ws = None
        self._connected = False
```

## 2. Proxmox API Helper

### 2.1 Proxmox vncproxy Endpoint

**Endpoint:** `POST /api2/json/nodes/{node}/qemu/{vmid}/vncproxy`

**Parameters:**
```python
{
    "generate-password": bool,  # Optional, default 0
    "websocket": bool,          # Optional, default 1 for websocket
}
```

**Response:**
```python
{
    "ticket": str,              # VNC ticket for authentication
    "port": int,                # WebSocket port
    "cert": str,                # PEM certificate (base64 in response)
    "password": str,            # Optional password (if generated)
    "upid": str,                # Unique Process ID
    "user": str,                # Username for audit
}
```

### 2.2 ProxmoxVNCHelper Implementation

```python
import json
import urllib.request
import urllib.parse
from typing import Dict, Any

class ProxmoxVNCHelper:
    """Helper for Proxmox VNC connections."""
    
    def __init__(
        self,
        proxmox_host: str,
        proxmox_port: int = 8006,
        token_id: str = "",
        token_secret: str = "",
        verify_ssl: bool = True,
    ) -> None:
        """
        Initialize Proxmox helper.
        
        Args:
            proxmox_host: Proxmox hostname or IP
            proxmox_port: Proxmox API port (default 8006)
            token_id: PVE API token ID (e.g., "user@realm!token-name")
            token_secret: PVE API token secret
## 2. Server Authentication: User Responsibility ⭐

**IMPORTANT:** The VNC Agent Bridge library does NOT make server-specific API calls. Users handle authentication using their preferred HTTP client or configuration method.

### 2.1 URL Template Pattern & Parameter Substitution

Users provide a URL template with placeholders, and library substitutes them:

**Template Variables:**
- `${host}` → Connection hostname
- `${port}` → Connection port
- `${ticket}` → Authentication ticket/token
- `${password}` → Authentication password (optional)

**Examples:**

Proxmox:
```
wss://${host}:${port}/api2/json/nodes/pve/qemu/100/vncwebsocket?vncticket=${ticket}
```

Custom WebSocket VNC:
```
wss://${host}:${port}/vnc/websocket?token=${ticket}
```

Static host with token:
```
wss://vnc.example.com:6900/qemu/${ticket}/websocket
```

### 2.2 Example: User Gets Connection Info from Proxmox

Users can use any HTTP client to get Proxmox connection info:

```python
import requests

# User calls Proxmox API (user responsibility)
response = requests.post(
    "https://proxmox.example.com:8006/api2/json/nodes/pve/qemu/100/vncproxy",
    headers={
        "Authorization": "PVEAPIToken=root@pam!token-id=token-secret",
    },
    json={
        "generate-password": False,
        "websocket": 1,
    },
    verify=True,
)

proxy_info = response.json()['data']
# proxy_info = {
#   "ticket": "PVE:node:xxxxxxx",
#   "port": 6900,
#   "cert": "-----BEGIN CERTIFICATE-----\n..."
# }

# Now user passes to library
from vnc_agent_bridge.core import WebSocketVNCConnection
from vnc_agent_bridge import VNCAgentBridge

url_template = "wss://${host}:${port}/api2/json/nodes/pve/qemu/100/vncwebsocket?vncticket=${ticket}"

ws_conn = WebSocketVNCConnection(
    url_template=url_template,
    host="proxmox.example.com",
    port=proxy_info['port'],
    ticket=proxy_info['ticket'],
    certificate_pem=proxy_info['cert'],
    verify_ssl=True,
)

with VNCAgentBridge(connection=ws_conn) as vnc:
    vnc.connect()
    vnc.mouse.left_click(100, 100)
```

### 2.3 Optional: Convenience Helper

The library provides an optional convenience function (NOT an API caller):

```python
from vnc_agent_bridge.proxmox import create_websocket_vnc

# After user gets proxy_info from Proxmox API...
with create_websocket_vnc(
    host="proxmox.example.com",
    port=proxy_info['port'],
    ticket=proxy_info['ticket'],
    certificate_pem=proxy_info['cert'],
) as vnc:
    vnc.mouse.left_click(100, 100)
```

### 2.3 Exception Hierarchy

```python
## 3. Exception Classes (Optional)

```python
class ProxmoxException(VNCException):
    """Base exception for Proxmox errors."""
    pass

class ProxmoxAuthError(ProxmoxException):
    """Authentication failed."""
    pass

class ProxmoxAPIError(ProxmoxException):
    """Proxmox API error (in user code, not library)."""
    pass

class ProxmoxVMError(ProxmoxException):
    """VM-related error."""
    pass
```

**Note:** These exception classes are optional. Users can use built-in exceptions or their own Proxmox exception handling.

## 4. Integration Usage Examples

### 4.1 Standard VNC (Unchanged)

```python
from vnc_agent_bridge import VNCAgentBridge

# Works exactly as before - no changes
with VNCAgentBridge('192.168.1.100', port=5900) as vnc:
    vnc.mouse.left_click(100, 100)
    vnc.keyboard.type_text("hello")
```

### 4.2 Proxmox WebSocket (User Handles API)

**Key Point:** User makes Proxmox API call and passes params to library.

```python
import requests
from vnc_agent_bridge.core import WebSocketVNCConnection
from vnc_agent_bridge import VNCAgentBridge

# STEP 1: User calls Proxmox API (not library)
response = requests.post(
    "https://proxmox.example.com:8006/api2/json/nodes/pve/qemu/100/vncproxy",
    headers={
        "Authorization": "PVEAPIToken=root@pam!mytoken=token_secret",
    },
    json={"websocket": 1},
    verify=True,
)

proxy_info = response.json()['data']

# STEP 2: Create WebSocket connection with params
ws_conn = WebSocketVNCConnection(
    host="proxmox.example.com",
    port=proxy_info['port'],
    ticket=proxy_info['ticket'],
    certificate_pem=proxy_info['cert'],
    verify_ssl=True,
)

# STEP 3: Use with VNCAgentBridge
with VNCAgentBridge(connection=ws_conn) as vnc:
    vnc.connect()
    vnc.mouse.left_click(100, 100)
    vnc.keyboard.type_text("hello")
```

### 4.3 With Convenience Helper (Optional)

```python
from vnc_agent_bridge.proxmox import create_websocket_vnc
import requests

# User still handles Proxmox API
response = requests.post(...)
proxy_info = response.json()['data']

# Convenience function (just sets up connection, NO API)
with create_websocket_vnc(
    host="proxmox.example.com",
    port=proxy_info['port'],
    ticket=proxy_info['ticket'],
    certificate_pem=proxy_info['cert'],
) as vnc:
    vnc.mouse.left_click(100, 100)
```

## 5. Error Handling

### 5.1 Proxmox API Errors (User Responsibility)

```python
import requests
from vnc_agent_bridge.core import WebSocketVNCConnection

try:
    # User handles API errors
    response = requests.post(
        "https://proxmox.example.com:8006/api2/json/nodes/pve/qemu/100/vncproxy",
        headers={"Authorization": "PVEAPIToken=..."},
        verify=True,
    )
    response.raise_for_status()
    proxy_info = response.json()['data']
    
    # Create connection
    ws_conn = WebSocketVNCConnection(
        host="proxmox.example.com",
        port=proxy_info['port'],
        ticket=proxy_info['ticket'],
        certificate_pem=proxy_info['cert'],
    )
    
except requests.exceptions.HTTPError as e:
    print(f"Proxmox API error: {e}")
except requests.exceptions.RequestException as e:
    print(f"Network error: {e}")
except Exception as e:
    print(f"VNC error: {e}")
```

### 5.2 Certificate Handling

```python
from vnc_agent_bridge.core import WebSocketVNCConnection

# Strict verification (default, recommended)
ws_conn = WebSocketVNCConnection(
    host="proxmox.example.com",
    port=6900,
    ticket="PVE:...",
    certificate_pem=cert_data,
    verify_ssl=True,  # Verify certificate
)

# Skip verification (development only)
ws_conn = WebSocketVNCConnection(
    host="proxmox.example.com",
    port=6900,
    ticket="PVE:...",
    certificate_pem=cert_data,
    verify_ssl=False,  # Don't verify (insecure!)
)
```

## 6. File Structure

```
vnc_agent_bridge/
├── __init__.py
├── core/
│   ├── __init__.py
│   ├── base_connection.py           # NEW: VNCConnectionBase abstract class
│   ├── connection_tcp.py             # REFACTORED: TCPVNCConnection
│   ├── connection_websocket.py       # NEW: WebSocketVNCConnection
│   ├── bridge.py                     # UPDATED: Accept VNCConnectionBase
│   ├── mouse.py
│   ├── keyboard.py
│   ├── scroll.py
│   └── clipboard.py
├── proxmox/                          # NEW: Optional Proxmox convenience module
│   ├── __init__.py
│   └── helpers.py                    # OPTIONAL: Simple helper functions (NO API)
├── exceptions/
│   └── __init__.py
└── types/
    └── common.py
```

**Note:** The proxmox/ module is optional and contains simple convenience functions only. It does NOT include ProxmoxVNCHelper or ProxmoxVNCBridge classes that make API calls.

## 7. Migration Guide for Developers

### For Library Users: No Changes Required
```python
# Old code - still works exactly the same
from vnc_agent_bridge import VNCAgentBridge

with VNCAgentBridge('localhost') as vnc:
    vnc.mouse.left_click(100, 100)
```

### For Proxmox Users: Handle API Yourself
```python
# New Proxmox usage: User handles API
import requests
from vnc_agent_bridge.core import WebSocketVNCConnection
from vnc_agent_bridge import VNCAgentBridge

# Step 1: User calls Proxmox API
response = requests.post(...)
proxy_info = response.json()['data']

# Step 2: Pass params to library
ws_conn = WebSocketVNCConnection(
    host=proxy_info['host'],
    port=proxy_info['port'],
    ticket=proxy_info['ticket'],
    certificate_pem=proxy_info['cert'],
)

# Step 3: Use with VNCAgentBridge
with VNCAgentBridge(connection=ws_conn) as vnc:
    vnc.mouse.left_click(100, 100)
```

### For Contributors: New Connection Types
```python
from vnc_agent_bridge.core import VNCConnectionBase

# Create custom connection type
class MyCustomConnection(VNCConnectionBase):
    def connect(self) -> None: ...
    def disconnect(self) -> None: ...
    # ... implement abstract methods
```

## 8. Testing Strategy

### Unit Tests
- Mock WebSocket connections
- Mock Proxmox API responses
- Test RFB message handling
- Test error scenarios

### Integration Tests
- Test full workflow with mocked services
- Test error recovery
- Test connection lifecycle

### Mock Strategy
```python
# Mock WebSocket
from unittest.mock import Mock, patch

@patch('websocket.create_connection')
def test_websocket_connection(mock_ws):
    mock_ws.return_value.send_binary = Mock()
    mock_ws.return_value.recv_frame = Mock(return_value=...)
    # Test code
```

## 9. Performance Considerations

1. **WebSocket Overhead:** ~5-10% compared to raw TCP
2. **TLS Handshake:** Adds ~100-500ms initially
3. **Frame Wrapping:** Minimal performance impact
4. **Proxmox API Calls:** Cached after initial connection

## 10. Security Considerations

1. **Certificate Verification:** Enabled by default
2. **Token Management:** Keep API tokens secure
3. **SSL/TLS:** Always use wss:// (encrypted)
4. **Ticket Lifetime:** Proxmox tickets expire after 2 hours

